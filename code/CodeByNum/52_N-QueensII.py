class Solution:
    def totalNQueens(self, n: int) -> int:
        if n < 1: return []
        # self.count 为全局变量
        self.count = 0
        # 从第 0 行 第 0 列开始调用DFS函数
        self._dfs(n, 0, 0, 0, 0)
        return self.count

    def _dfs(self, n, row, cols, pie, na):
        # recursion terminator
        if row >= n:
            # 在此计数的原因，是遍历 bits 时不断递归往下一层走，直到其中一次
            self.count += 1
            return

        # 得到当前所有的空位，解释如下：
        # 用二进制原码表示哪个位置可以放皇后，首先用 1 表示被占，0 表示可放
        # 用 | 运算符，即 '或' 运算符，将 cols pie na 三个二进制原码 '或' 起来，从而得出一共有哪些位置可以放皇后
        # ~ 表示取反，在 cols | pie | na 进行完 '或' 运算后，将原本表示被占的 1 和可放的 0 取反
        # 例如：原码为 0110，取反后得 1001，从而用 1 表示可放，0 表示被占
        # 1 << n 这个操作是左移，假如 n 为 4，则 1 往左移 4位
        # 从0000...00001(此处一共32位，因为是 int 类型) 变成 0000...10000(此处还是32位)
        # '- 1' 是为了将0000...10000减成0000...01111，从而得到4位 '1'
        # 1001 & 1111 = 1001，此处 1 还是表示可放，而 0 表示被占，将 1 表示可放的原因就是为了下面 while 循环方便
        bits = (~(cols | pie | na)) & ((1 << n) - 1)  # 得到当前所有的空位，空位用1表示

        # 递归思想：如果从第一行开始，遍历到当前行数为倒数第二行后，从bits = (~(cols | pie | na)) & ((1 << n) - 1)
        # 获得最后一个空位，然后通过 p 取出来用以放下皇后，那么这个皇后就是最后一行的皇后
        # 同理可得从第 0 行开始，在调用DFS前通过 p 取得第一行应该放下皇后的位置
        # 总体递归 第 0 行，找出第一行放下皇后的位置，通过调用self.DFS遍历到第 1 行，在当前行为第一行的情况下找到第二行
        # 可以放皇后的位置
        # 递归思想一定要遵循 '最多能放置的皇后的位置'
        while bits:
            # 为了得到一个空位，得到之后将 p 和 cols pie na 三个参数 '或' 起来，如下方代码调用DFS一般
            # 位运算，假如bits = 5，其二进制原码为 0101，而 -5 在计算机中用补码形式存放，即原码取反加一得 1011
            # 0101 & 1011 = 0001，因此bits & -bits 的作用是得到末位1的位置
            p = bits & -bits  # 取到最低位的1

            # 遵循深度搜索的原则，向下搜索则 row + 1，p 和 cols pie na '或' 起来后就更新了这三个参数然后递归下去
            self._dfs(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1)

            # 去除二进制的末位 1
            # 从python运算符来看 '-' 运算符的优先级比 '&' 运算符要高，因此代码bits & bits - 1不需要把bits - 1括起来
            bits = bits & (bits - 1)  # 去掉最低位的1